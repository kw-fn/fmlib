<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (fmlib.Fmlib_parse.Generic.Make)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">fmlib</a> &#x00BB; <a href="../../index.html">Fmlib_parse</a> &#x00BB; <a href="../index.html">Generic</a> &#x00BB; Make</nav><h1>Module <code>Generic.Make</code></h1><nav class="toc"><ul><li><a href="#final-parser">Final parser</a></li><li><a href="#generic-combinators">Generic Combinators</a></li><li><a href="#elementary-parsing-step">Elementary Parsing Step</a></li><li><a href="#make-the-final-parser">Make the Final Parser</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-Token/index.html">Token</a> : <a href="../../../Fmlib_std/Interfaces/index.html#module-type-ANY">Fmlib_std.Interfaces.ANY</a></code></li><li><code><a href="argument-2-State/index.html">State</a> : <a href="../../../Fmlib_std/Interfaces/index.html#module-type-ANY">Fmlib_std.Interfaces.ANY</a></code></li><li><code><a href="argument-3-Expect/index.html">Expect</a> : <a href="../../../Fmlib_std/Interfaces/index.html#module-type-ANY">Fmlib_std.Interfaces.ANY</a></code></li><li><code><a href="argument-4-Semantic/index.html">Semantic</a> : <a href="../../../Fmlib_std/Interfaces/index.html#module-type-ANY">Fmlib_std.Interfaces.ANY</a></code></li><li><code><a href="argument-5-Final/index.html">Final</a> : <a href="../../../Fmlib_std/Interfaces/index.html#module-type-ANY">Fmlib_std.Interfaces.ANY</a></code></li></ul><h3 class="heading">Signature</h3><aside><ul><li><code>Token.t</code> Token type</li><li><code>State.t</code> Type of the user state</li><li><code>Expect.t</code> Type of syntax messages which are generated, when something has been expected but not found.</li><li><code>Semantic.t</code> Type of semantic error messages. Triggered by <code>fail
        error</code>.</li><li><code>Final.t</code> Type of the returned object, when parsing has finished.</li></ul></aside><section><header><h2 id="final-parser"><a href="#final-parser" class="anchor"></a>Final parser</h2></header><dl><dt class="spec module" id="module-Parser"><a href="#module-Parser" class="anchor"></a><code><span class="keyword">module</span> <a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The final parser.</p></dd></dl></section><section><header><h2 id="generic-combinators"><a href="#generic-combinators" class="anchor"></a>Generic Combinators</h2></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Interfaces/index.html#module-type-COMBINATOR">Interfaces.COMBINATOR</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../Interfaces/module-type-COMBINATOR/index.html#type-state">state</a> = <a href="argument-2-State/index.html#type-t">State.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../Interfaces/module-type-COMBINATOR/index.html#type-expect">expect</a> = <a href="argument-3-Expect/index.html#type-t">Expect.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../Interfaces/module-type-COMBINATOR/index.html#type-semantic">semantic</a> = <a href="argument-4-Semantic/index.html#type-t">Semantic.t</a></code></span></summary><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code><code> = <a href="argument-2-State/index.html#type-t">State.t</a></code></dt><dt class="spec type" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span class="keyword">type</span> expect</code><code> = <a href="argument-3-Expect/index.html#type-t">Expect.t</a></code></dt><dt class="spec type" id="type-semantic"><a href="#type-semantic" class="anchor"></a><code><span class="keyword">type</span> semantic</code><code> = <a href="argument-4-Semantic/index.html#type-t">Semantic.t</a></code></dt></dl><section><header><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>_ t</span></code></dt><dd><p><code>'a t</code> Type of a parse combinator returning an <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;&gt;= f</code></p><p>Parse first the input according to the combinator <code>p</code>. In case of success, feed the returned value of <code>p</code> into the function <code>f</code> to get the combinator to parse next.</p></dd></dl><dl><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>let* x = p in f x</code> is equivalent to <code>p &gt;&gt;= f</code></p><p>The <code>let*</code> combinator let us express parsing sequences conveniently. Example:</p><pre><code class="ml">let* x = p in       (* parse [p], result [x] in case of success. *)
let* y = q x in     (* parse [q x], result [y] ... *)
let* z = r x y in   (* ... *)
...
return f x y z ...</code></pre><p>The wildcard <code>let* _ = ...</code> can be used to ignore results of intermediate parsing steps.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned value <code>x</code> to <code>f
        x</code>. In case of failure, do nothing.</p><p><code>map f p</code> is equivalent to <code>let* x = p in return (f x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span class="keyword">val</span> succeed : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>succeed a</code></p><p>Succeed immediately without consuming token. Return object <code>a</code> as result.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return a</code> is equivalent to <code>succeed a</code>.</p></dd></dl><dl><dt class="spec value" id="val-unexpected"><a href="#val-unexpected" class="anchor"></a><code><span class="keyword">val</span> unexpected : <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unexpected expect</code> triggers a syntax error signalling the expectation <code>expect</code>.</p></dd></dl><dl><dt class="spec value" id="val-clear_last_expectation"><a href="#val-clear_last_expectation" class="anchor"></a><code><span class="keyword">val</span> clear_last_expectation : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>clear_last_expectation p</code> Clear last failed expectation.</p><p>This is useful e.g. after stripping whitespace. Since stripping whitespace means <code>skip_one_or_more ws</code> or <code>skip_zero_or_more ws</code>, after skipping whitespace the parser can still expect more whitespace. Therefore there is a failed expectation *whitespace* on the stack. However you rarely want this expectation to be reported.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : <a href="index.html#type-semantic">semantic</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fail error</code> triggers a semantic error.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;/&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;/&gt; q</code></p><p>Try first combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;/&gt; q</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then <code>p &lt;/&gt; q</code> is equivalent to <code>q</code>.</p></dd></dl><dl><dt class="spec value" id="val-choices"><a href="#val-choices" class="anchor"></a><code><span class="keyword">val</span> choices : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>choices p [q r t ...]</code> is equivalent to <code>p &lt;/&gt; q &lt;/&gt; r &lt;/&gt; t &lt;/&gt; ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;?&gt; expect</code></p><p>Try combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;?&gt; expect</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then the failed expectations are replaced with the failed expectation <code>expect</code>.</p><p>Usually <code>p</code> is a combinator implementing a choice between various alternatives of a grammar construct. The <code>&lt;?&gt;</code> combinator allows to replace the set of failed grammar alternatives with a higher abstraction of the failed expectation. E.g. instead of getting the failed expectations <code>identifier</code>, <code>'('</code>, <code>-</code>, ... we can get the failed expectation <code>expression</code>.</p></dd></dl></section><section><header><h3 id="state-combinators"><a href="#state-combinators" class="anchor"></a>State Combinators</h3></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><a href="index.html#type-state">state</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Get the current user state.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <span>(<a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update f</code> Update the user state using <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_and_update"><a href="#val-get_and_update" class="anchor"></a><code><span class="keyword">val</span> get_and_update : <span>(<a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-state">state</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>get_and_update f</code> Get the current user state and then update the user state. The returned value is the old state.</p></dd></dl></section><section><header><h3 id="convenience-combinators"><a href="#convenience-combinators" class="anchor"></a>Convenience Combinators</h3></header><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>optional p</code></p><p>Try combinator <code>p</code>.</p><ul><li>Success: Return <code>Some a</code> where <code>a</code> is the returned value.</li><li>Failure without consuming token: Return <code>None</code></li><li>Failure with consuming token: Remain in the error state.</li></ul></dd></dl><dl><dt class="spec value" id="val-zero_or_more"><a href="#val-zero_or_more" class="anchor"></a><code><span class="keyword">val</span> zero_or_more : <span class="type-var">'r</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zero_or_more start f p</code></p><p>Try the combinator <code>p</code> as often as possible. Return <code>start</code> if <code>p</code> fails without consuming token. As long as <code>p</code> succeeds use <code>f</code> to accumulate the results.</p><p>The first time <code>p</code> fails without consuming token, return the accumulated result.</p><p>If <code>p</code> fails by consuming token, then <code>zero_or_more f p</code> fails with the same error.</p></dd></dl><dl><dt class="spec value" id="val-one_or_more"><a href="#val-one_or_more" class="anchor"></a><code><span class="keyword">val</span> one_or_more : <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>one_or_more first next p</code></p><p><code>one_or_more first next p</code> is equivalent to</p><pre><code class="ml">let* x = p in
zero_or_more (first x) next p</code></pre></dd></dl><dl><dt class="spec value" id="val-list_zero_or_more"><a href="#val-list_zero_or_more" class="anchor"></a><code><span class="keyword">val</span> list_zero_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list_zero_or_more p</code> Parse zero or more occurrences of <code>p</code> and returned the collected result in a list.</p></dd></dl><dl><dt class="spec value" id="val-list_one_or_more"><a href="#val-list_one_or_more" class="anchor"></a><code><span class="keyword">val</span> list_one_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list_zero_or_more p</code> Parse one or more occurrences of <code>p</code> and returned the collected results as a pair of the first value and a list of the remaining values.</p></dd></dl><dl><dt class="spec value" id="val-skip_zero_or_more"><a href="#val-skip_zero_or_more" class="anchor"></a><code><span class="keyword">val</span> skip_zero_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_zero_or_more p</code> Parse zero or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></dd></dl><dl><dt class="spec value" id="val-skip_one_or_more"><a href="#val-skip_one_or_more" class="anchor"></a><code><span class="keyword">val</span> skip_one_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_one_or_more p</code> Parse one or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></dd></dl><dl><dt class="spec value" id="val-one_or_more_separated"><a href="#val-one_or_more_separated" class="anchor"></a><code><span class="keyword">val</span> one_or_more_separated : <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'sep</span> <span>&#45;&gt;</span> <span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'sep</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>one_or_more_separated first next p sep</code></p><p>Parse one or more occurrences of <code>p</code> separated by <code>sep</code>. Use <code>first</code> to convert the first occurrence of <code>p</code> into the result and use <code>next</code> to accumulate the results.</p></dd></dl></section><section><header><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3></header><dl><dt class="spec value" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span class="keyword">val</span> backtrack : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>backtrack p expect</code></p><p>Try the combinator <code>p</code>. In case of failure with consuming token, push the consumed token back to the lookahead and let it fail without consuming token. Use <code>expect</code> to record the failed expectation.</p><p>Backtracking reduces the performance, because the token pushed back to the lookahead have to be parsed again. Try to avoid backtracking whenever possible.</p></dd></dl><dl><dt class="spec value" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span class="keyword">val</span> followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>followed_by</code> parser succeeds without consuming token. Otherwise it fails without consuming tokens.</p></dd></dl><dl><dt class="spec value" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>not_followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>not_followed_by</code> parser fails without consuming token. Otherwise it succeeds without consuming tokens.</p></dd></dl><aside><p><code>followed_by</code> and <code>not_followed_by</code> can be used to peek into the token stream without consuming token.</p></aside></section></details></div></div></div></section><section><header><h2 id="elementary-parsing-step"><a href="#elementary-parsing-step" class="anchor"></a>Elementary Parsing Step</h2></header><dl><dt class="spec value" id="val-step"><a href="#val-step" class="anchor"></a><code><span class="keyword">val</span> step : <span>(<a href="argument-2-State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="argument-1-Token/index.html#type-t">Token.t</a> option</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <a href="argument-2-State/index.html#type-t">State.t</a>, <a href="argument-3-Expect/index.html#type-t">Expect.t</a>)</span> Stdlib.result</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>step f</code></p><p>Elementary parsing step.</p><p>The function <code>f</code> is called with two arguments:</p><ul><li>The current state</li><li>The next lookahead token (or none, if the end of the token stream has been reached).</li></ul><p><code>f</code> must return either an object of type <code>'a</code> and a new state if it accepts the token, or a failed expectation if it rejects the token.</p></dd></dl></section><section><header><h2 id="make-the-final-parser"><a href="#make-the-final-parser" class="anchor"></a>Make the Final Parser</h2></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <a href="argument-2-State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="argument-5-Final/index.html#type-t">Final.t</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<a href="argument-2-State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <a href="argument-3-Expect/index.html#type-t">Expect.t</a>)</span> <span>&#45;&gt;</span> <a href="Parser/index.html#type-t">Parser.t</a></code></dt><dd><p><code>make state p e</code> Makes a parser.</p><ul><li><code>state</code> Initial state</li><li><code>p</code> Combinator which returns in case of success an object of type <code>Final.t</code></li><li><code>e</code> Error function. Generates an expectation from the state. The function is used if at the expected end of input other token arrive.</li></ul><p>The generated parser expects a token stream which can be successfully parsed by the combinator <code>p</code> and then it expects the end of input.</p></dd></dl><dl><dt class="spec value" id="val-make_parser"><a href="#val-make_parser" class="anchor"></a><code><span class="keyword">val</span> make_parser : <a href="argument-2-State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="argument-5-Final/index.html#type-t">Final.t</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="Parser/index.html#type-t">Parser.t</a></code></dt></dl></section></div></body></html>