<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (fmlib.Parse__Character.Make)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">fmlib</a> &#x00BB; <a href="../index.html">Parse__Character</a> &#x00BB; Make</nav><h1>Module <code>Parse__Character.Make</code></h1><nav class="toc"><ul><li><a href="#final-parser">Final Parser</a></li><li><a href="#generic-combinators">Generic Combinators</a></li><li><a href="#location-combinator">Location Combinator</a></li><li><a href="#indentation-combinators">Indentation Combinators</a></li><li><a href="#make-the-final-parser">Make the Final Parser</a></li><li><a href="#character-combinators">Character Combinators</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-State/index.html">State</a> : <a href="../../Std/Interfaces/index.html#module-type-ANY">Std.Interfaces.ANY</a></code></li><li><code><a href="argument-2-Final/index.html">Final</a> : <a href="../../Std/Interfaces/index.html#module-type-ANY">Std.Interfaces.ANY</a></code></li><li><code><a href="argument-3-Semantic/index.html">Semantic</a> : <a href="../../Std/Interfaces/index.html#module-type-ANY">Std.Interfaces.ANY</a></code></li></ul><h3 class="heading">Signature</h3><aside><ul><li><code>State</code>: User state.</li><li><code>Final</code>: Final result type of the parser.</li><li><code>Semantic</code>: Semantic error message (triggered by <code>fail error</code>)</li></ul></aside><section><header><h2 id="final-parser"><a href="#final-parser" class="anchor"></a>Final Parser</h2></header><div class="spec module" id="module-Parser"><a href="#module-Parser" class="anchor"></a><code><span class="keyword">module</span> <a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h2 id="generic-combinators"><a href="#generic-combinators" class="anchor"></a>Generic Combinators</h2></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Parse/Interfaces/index.html#module-type-COMBINATOR">Parse.Interfaces.COMBINATOR</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../Parse/Interfaces/module-type-COMBINATOR/index.html#type-state">state</a> = <a href="argument-1-State/index.html#type-t">State.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../Parse/Interfaces/module-type-COMBINATOR/index.html#type-expect">expect</a> = string <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../Parse/Interfaces/module-type-COMBINATOR/index.html#type-semantic">semantic</a> = <a href="argument-3-Semantic/index.html#type-t">Semantic.t</a></code></span></summary><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code><code> = <a href="argument-1-State/index.html#type-t">State.t</a></code></dt><dt class="spec type" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span class="keyword">type</span> expect</code><code> = string</code></dt><dt class="spec type" id="type-semantic"><a href="#type-semantic" class="anchor"></a><code><span class="keyword">type</span> semantic</code><code> = <a href="argument-3-Semantic/index.html#type-t">Semantic.t</a></code></dt></dl><section><header><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>_ t</span></code></dt><dd><p><code>'a t</code> Type of a parse combinator returning an <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;&gt;= f</code></p><p>Parse first the input according to the combinator <code>p</code>. In case of success, feed the returned value of <code>p</code> into the function <code>f</code> to get the combinator to parse next.</p></dd></dl><dl><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>let* x = p in f x</code> is equivalent to <code>p &gt;&gt;= f</code></p><p>The <code>let*</code> combinator let us express parsing sequences conveniently. Example:</p><pre><code class="ml">let* x = p in       (* parse [p], result [x] in case of success. *)
let* y = q x in     (* parse [q x], result [y] ... *)
let* z = r x y in   (* ... *)
...
return f x y z ...</code></pre><p>The wildcard <code>let* _ = ...</code> can be used to ignore results of intermediate parsing steps.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned value <code>x</code> to <code>f
        x</code>. In case of failure, do nothing.</p><p><code>map f p</code> is equivalent to <code>let* x = p in return (f x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span class="keyword">val</span> succeed : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>succeed a</code></p><p>Succeed immediately without consuming token. Return object <code>a</code> as result.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return a</code> is equivalent to <code>succeed a</code>.</p></dd></dl><dl><dt class="spec value" id="val-unexpected"><a href="#val-unexpected" class="anchor"></a><code><span class="keyword">val</span> unexpected : <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unexpected expect</code> triggers a syntax error signalling the expectation <code>expect</code>.</p></dd></dl><dl><dt class="spec value" id="val-clear_last_expectation"><a href="#val-clear_last_expectation" class="anchor"></a><code><span class="keyword">val</span> clear_last_expectation : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>clear_last_expectation p</code> Clear last failed expectation.</p><p>This is useful e.g. after stripping whitespace. Since stripping whitespace means <code>skip_one_or_more ws</code> or <code>skip_zero_or_more ws</code>, after skipping whitespace the parser can still expect more whitespace. Therefore there is a failed expectation *whitespace* on the stack. However you rarely want this expectation to be reported.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : <a href="index.html#type-semantic">semantic</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fail error</code> triggers a semantic error.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;/&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;/&gt; q</code></p><p>Try first combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;/&gt; q</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then <code>p &lt;/&gt; q</code> is equivalent to <code>q</code>.</p></dd></dl><dl><dt class="spec value" id="val-choices"><a href="#val-choices" class="anchor"></a><code><span class="keyword">val</span> choices : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>choices p [q r t ...]</code> is equivalent to <code>p &lt;/&gt; q &lt;/&gt; r &lt;/&gt; t &lt;/&gt; ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;?&gt; expect</code></p><p>Try combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;?&gt; expect</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then the failed expectations are replaced with the failed expectation <code>expect</code>.</p><p>Usually <code>p</code> is a combinator implementing a choice between various alternatives of a grammar construct. The <code>&lt;?&gt;</code> combinator allows to replace the set of failed grammar alternatives with a higher abstraction of the failed expectation. E.g. instead of getting the failed expectations <code>identifier</code>, <code>'('</code>, <code>-</code>, ... we can get the failed expectation <code>expression</code>.</p></dd></dl></section><section><header><h3 id="state-combinators"><a href="#state-combinators" class="anchor"></a>State Combinators</h3></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><a href="index.html#type-state">state</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Get the current user state.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <span>(<a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update f</code> Update the user state using <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_and_update"><a href="#val-get_and_update" class="anchor"></a><code><span class="keyword">val</span> get_and_update : <span>(<a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-state">state</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>get_and_update f</code> Get the current user state and then update the user state. The returned value is the old state.</p></dd></dl></section><section><header><h3 id="convenience-combinators"><a href="#convenience-combinators" class="anchor"></a>Convenience Combinators</h3></header><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>optional p</code></p><p>Try combinator <code>p</code>.</p><ul><li>Success: Return <code>Some a</code> where <code>a</code> is the returned value.</li><li>Failure without consuming token: Return <code>None</code></li><li>Failure with consuming token: Remain in the error state.</li></ul></dd></dl><dl><dt class="spec value" id="val-zero_or_more"><a href="#val-zero_or_more" class="anchor"></a><code><span class="keyword">val</span> zero_or_more : <span class="type-var">'r</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zero_or_more start f p</code></p><p>Try the combinator <code>p</code> as often as possible. Return <code>start</code> if <code>p</code> fails without consuming token. As long as <code>p</code> succeeds use <code>f</code> to accumulate the results.</p><p>The first time <code>p</code> fails without consuming token, return the accumulated result.</p><p>If <code>p</code> fails by consuming token, then <code>zero_or_more f p</code> fails with the same error.</p></dd></dl><dl><dt class="spec value" id="val-one_or_more"><a href="#val-one_or_more" class="anchor"></a><code><span class="keyword">val</span> one_or_more : <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>one_or_more first next p</code></p><p><code>one_or_more first next p</code> is equivalent to</p><pre><code class="ml">let* x = p in
zero_or_more (first x) next p</code></pre></dd></dl><dl><dt class="spec value" id="val-list_zero_or_more"><a href="#val-list_zero_or_more" class="anchor"></a><code><span class="keyword">val</span> list_zero_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list_zero_or_more p</code> Parse zero or more occurrences of <code>p</code> and returned the collected result in a list.</p></dd></dl><dl><dt class="spec value" id="val-list_one_or_more"><a href="#val-list_one_or_more" class="anchor"></a><code><span class="keyword">val</span> list_one_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list_zero_or_more p</code> Parse one or more occurrences of <code>p</code> and returned the collected results as a pair of the first value and a list of the remaining values.</p></dd></dl><dl><dt class="spec value" id="val-skip_zero_or_more"><a href="#val-skip_zero_or_more" class="anchor"></a><code><span class="keyword">val</span> skip_zero_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_zero_or_more p</code> Parse zero or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></dd></dl><dl><dt class="spec value" id="val-skip_one_or_more"><a href="#val-skip_one_or_more" class="anchor"></a><code><span class="keyword">val</span> skip_one_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_one_or_more p</code> Parse one or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></dd></dl><dl><dt class="spec value" id="val-one_or_more_separated"><a href="#val-one_or_more_separated" class="anchor"></a><code><span class="keyword">val</span> one_or_more_separated : <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'sep</span> <span>&#45;&gt;</span> <span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'sep</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>one_or_more_separated first next p sep</code></p><p>Parse one or more occurrences of <code>p</code> separated by <code>sep</code>. Use <code>first</code> to convert the first occurrence of <code>p</code> into the result and use <code>next</code> to accumulate the results.</p></dd></dl></section><section><header><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3></header><dl><dt class="spec value" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span class="keyword">val</span> backtrack : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>backtrack p expect</code></p><p>Try the combinator <code>p</code>. In case of failure with consuming token, push the consumed token back to the lookahead and let it fail without consuming token. Use <code>expect</code> to record the failed expectation.</p><p>Backtracking reduces the performance, because the token pushed back to the lookahead have to be parsed again. Try to avoid backtracking whenever possible.</p></dd></dl><dl><dt class="spec value" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span class="keyword">val</span> followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>followed_by</code> parser succeeds without consuming token. Otherwise it fails without consuming tokens.</p></dd></dl><dl><dt class="spec value" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>not_followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>not_followed_by</code> parser fails without consuming token. Otherwise it succeeds without consuming tokens.</p></dd></dl><aside><p><code>followed_by</code> and <code>not_followed_by</code> can be used to peek into the token stream without consuming token.</p></aside></section></details></div></div></div></section><section><header><h2 id="location-combinator"><a href="#location-combinator" class="anchor"></a>Location Combinator</h2></header><dl><dt class="spec value" id="val-located"><a href="#val-located" class="anchor"></a><code><span class="keyword">val</span> located : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../../Parse/Located/index.html#type-t">Parse.Located.t</a></span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>located p</code> Parse <code>p</code> and return its result with its start and end position.</p><p>Note: If <code>p</code> parses strips whitespace at the end, the returned end position is at the end of the whitespace. This is not what you usually want. Therefore first parse the essential part located and then strip the whitespace.</p></dd></dl></section><section><header><h2 id="indentation-combinators"><a href="#indentation-combinators" class="anchor"></a>Indentation Combinators</h2></header><dl><dt class="spec value" id="val-indent"><a href="#val-indent" class="anchor"></a><code><span class="keyword">val</span> indent : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>indent i p</code> Indent <code>p</code> by <code>i</code> columns relative to its parent.</p><p>Precondition: <code>0 &lt;= i</code></p></dd></dl><dl><dt class="spec value" id="val-align"><a href="#val-align" class="anchor"></a><code><span class="keyword">val</span> align : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>align p</code></p><p>Set the indentation set of <code>p</code> to <code>{col}</code> where <code>col</code> is the column position of its first character. Fail, if <code>col</code> is not in the indentation set.</p></dd></dl><dl><dt class="spec value" id="val-left_align"><a href="#val-left_align" class="anchor"></a><code><span class="keyword">val</span> left_align : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left_align p</code></p><p>Set the indentation set of <code>p</code> to <code>{col}</code> where <code>col</code> is the column position of its first character. Fail, if <code>col</code> is not the lower bound of the indentation set. I.e. <code>p</code> is left aligned in its indentation set.</p></dd></dl><dl><dt class="spec value" id="val-detach"><a href="#val-detach" class="anchor"></a><code><span class="keyword">val</span> detach : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>detach p</code> Parse <code>p</code> without any indentation and alignment restrictions.</p></dd></dl><dl><dt class="spec value" id="val-zero_or_more_aligned"><a href="#val-zero_or_more_aligned" class="anchor"></a><code><span class="keyword">val</span> zero_or_more_aligned : <span class="type-var">'r</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zero_or_more_aligned start next p</code></p><p>Parse an indented block of zero or more aligned constructs <code>p</code>.</p><p>Equivalent to</p><pre><code class="ml">zero_or_more start next (align p) |&gt; align |&gt; indent 1</code></pre></dd></dl><dl><dt class="spec value" id="val-one_or_more_aligned"><a href="#val-one_or_more_aligned" class="anchor"></a><code><span class="keyword">val</span> one_or_more_aligned : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zero_or_more_aligned first next p</code></p><p>Parse an indented block of one or more aligned constructs <code>p</code>.</p><p>Equivalent to</p><pre><code class="ml">one_or_more first next (align p) |&gt; align |&gt; indent 1</code></pre></dd></dl></section><section><header><h2 id="make-the-final-parser"><a href="#make-the-final-parser" class="anchor"></a>Make the Final Parser</h2></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <a href="argument-1-State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="argument-2-Final/index.html#type-t">Final.t</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="Parser/index.html#type-t">Parser.t</a></code></dt><dt class="spec value" id="val-make_parser"><a href="#val-make_parser" class="anchor"></a><code><span class="keyword">val</span> make_parser : <a href="../../Parse/Position/index.html#type-t">Parse.Position.t</a> <span>&#45;&gt;</span> <a href="argument-1-State/index.html#type-t">State.t</a> <span>&#45;&gt;</span> <span><a href="argument-2-Final/index.html#type-t">Final.t</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="Parser/index.html#type-t">Parser.t</a></code></dt></dl></section><section><header><h2 id="character-combinators"><a href="#character-combinators" class="anchor"></a>Character Combinators</h2></header><dl><dt class="spec value" id="val-charp"><a href="#val-charp" class="anchor"></a><code><span class="keyword">val</span> charp : <span>(char <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-one_of_chars"><a href="#val-one_of_chars" class="anchor"></a><code><span class="keyword">val</span> one_of_chars : string <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-uppercase_letter"><a href="#val-uppercase_letter" class="anchor"></a><code><span class="keyword">val</span> uppercase_letter : <span>char <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-lowercase_letter"><a href="#val-lowercase_letter" class="anchor"></a><code><span class="keyword">val</span> lowercase_letter : <span>char <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-letter"><a href="#val-letter" class="anchor"></a><code><span class="keyword">val</span> letter : <span>char <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-digit"><a href="#val-digit" class="anchor"></a><code><span class="keyword">val</span> digit : <span>int <a href="index.html#type-t">t</a></span></code></dt></dl></section></div></body></html>