<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parse (fmlib.Parse)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">fmlib</a> &#x00BB; Parse</nav><h1>Module <code>Parse</code></h1><p>Parsing Library</p><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#construction-of-parsers">Construction of Parsers</a></li><li><a href="#calculator-example">Calculator Example</a></li><li><a href="#avoid-infinite-recursion">Avoid Infinite Recursion</a></li><li><a href="#backtracking">Backtracking</a></li><li><a href="#indentation-parsing">Indentation Parsing</a></li><li><a href="#api">API</a></li></ul></nav></header><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2></header><aside><p>The parsers of this library implement parsers for <i>Parsing Expression Grammars</i> with parsing combinators. They have the following main features:</p><ul><li>Like all combinator parsers (e.g. like <code>parsec</code> of Haskell) you have the full flexibility of a functional language. There is no preprocessing step where the parser has to be generated from the grammar.</li></ul><ul><li>All parsers are incremental and work in push mode. You can parse part of the input stream, look into the state of the parser. Store the parser at different locations and resume parsing at any location in the input stream.</li></ul><ul><li>The character parser (i.e. the parser which works on streams of characters like files) parses indentation sensitive grammars.</li></ul><p>These features in combination are to the best of our knowledge unique in <code>Fmlib</code>.</p><p>Parsing expression grammars look are very similar to context free grammers. There are two main differences:</p><ul><li>The choice between alternatives is biased. I.e. if parsing of the first alternative succeeds, then the next one is not parsed.</li></ul><ul><li>Left recursion is forbidden.</li></ul><p>Accepting these restrictions leads to fairly efficient parser which can be implemented directly in a functional language.</p><p>A parsing expression in a parsing expression grammar is one of:</p><ul><li>A token</li></ul><ul><li>A sequence of expressions <code>e₁ e₂ ...</code></li></ul><ul><li>A biased choice between expressions <code>e₁ / e₂ / ... </code></li></ul><ul><li>Zero or more of an expression <code>e+</code></li></ul><ul><li>One or more of an expression <code>e*</code></li></ul></aside></section><section><header><h2 id="construction-of-parsers"><a href="#construction-of-parsers" class="anchor"></a>Construction of Parsers</h2></header><aside><p>You build a parser by first using combinators to express your grammar. A combinator has type <code>'a t</code> which parses some part of the input stream and returns an object of type <code>'a</code> in case of success.</p><p>All parsers have some elementary combinators which parse one token and succeed or fail. E.g. the character parser has a combinator <code>char c</code> which succeeds, if the next character is <code>c</code> and fails otherwise. Or there is the combinator <code>charp p</code> where <code>p</code> is a function of type <code>char -&gt; bool</code>. This combinator succeeds if the next character satisfies <code>p</code> and fails otherwise.</p><p>As the name implies, combinators can be combined to form more complex combinators. The <code>let*</code> combinator allows to form sequences of grammar constructs. E.g. if we have some combinators <code>p</code>, <code>q</code> and <code>r</code> which parse certain grammar constructs, we can combine them sequentially by</p><pre><code class="ml">let* x = p in
let* y = q in
let* z = r in
return (f x y z)</code></pre><p>This combinator first parses <code>p</code> which returns in case of success some value <code>x</code>. Then it parses <code>q</code> which returns a <code>y</code>. Then it parses <code>r</code> which returns a <code>z</code>. At the end it computes the compound result from the individual results <code>x</code>, <code>y</code> and <code>z</code>.</p><p>The sequence combinator fails, if one of its components fail and it succeeds, if all components succeed.</p><p>Needless to say that the combinators <code>p</code>, <code>q</code> and <code>r</code> can receive arguments and <code>q</code> and <code>r</code> can use <code>x</code> and <code>r</code> can use <code>x</code> and <code>y</code>.</p><p>For the biased choice there is the operator <code>&lt;/&gt;</code>. Having three combinators <code>p</code>, <code>q</code> and <code>r</code> of the same type the expression</p><pre><code class="ml">p &lt;/&gt; q &lt;/&gt; r</code></pre><p>is a new combinator which first parses <code>p</code>. In case <code>p</code> fails without consuming token, the next combinator <code>q</code> is used and so on.</p><p>There is the combinator <code>backtrackable p</code> which let <code>p</code> fail without consuming input even if it fails after consuming some token.</p><p>More detailed combinators can be seen in the APIs of the different parsers.</p><p>In order to do the actual parsing we need some combinator <code>c</code> which has type <code>final t</code> where <code>final</code> is the desired result after parsing successfully the complete input stream. From this combinator we can create a complete parser by</p><pre><code class="ml">make initial_state c</code></pre><p>This object is the parser object. If you don't need a user state, then the initial state is just unit <code>()</code>. You can push token into the parser object by</p><pre><code class="ml">put token p</code></pre><p>which returns a parser object into which step by step all token can be pushed. At the end of input you call</p><pre><code class="ml">put_end p</code></pre><p>which terminates the parse. There are methods like</p><pre><code class="ml">needs_more p        (* Does the parser need more input? *)
has_ended p         (* Has the parser finished parsing? *)
has_succeeded p     (* Has the parser finished successfully? *)

final p             (* The final result after successful parsing. *)
...</code></pre></aside></section><section><header><h2 id="calculator-example"><a href="#calculator-example" class="anchor"></a>Calculator Example</h2></header><aside><p>In the following we define a parser which parses and evaluates arithmetic expressions with addition, substraction, multiplication and division. Only division can trigger the semantic failure <i>division by zero</i>.</p><p>We want to parse a stream of characters.</p><pre><code class="ml">module Semantic = struct
    type t = Pretty.Print.doc
end

module CP =
    Parse.Character.Make
        (Unit)                  (* No state needed. *)
        (Int)                   (* The parser returns a number. *)
        (String)                (* The possible semantic error. *)
open CP</code></pre><p>Some combinators to parse whitespace, arithmetic operators and numbers.</p><pre><code class="ml">let whitespace: int t =
    skip_zero_or_more (char ' ')

type addop = Plus  | Minus
type mulop = Times | Divide

let operator (c: char) (op: 'a): 'a t =
    map (fun _ -&gt; op) (char c)

let addop: addop t =
    (* Parse an addition operator. *)
    let* op = operator '+' Plus &lt;/&gt; operator '-' Minus in
    let* _  = whitespace in      (* strip whitespace *)
    return op

let mulop: mulop t =
    (* Parse a multiplication operator. *)
    let* op = operator '*' Times &lt;/&gt; operator '/' Divide in
    let* _  = whitespace in      (* strip whitespace *)
    return op

let number: int t =
    (* Parse one number. *)
    let* v =
        one_or_more
            (fun d -&gt; d)
            (fun v d -&gt; 10 * v + d)
            digit
    in
    let* _ = whitespace in      (* strip whitespace *)
    return v</code></pre><p>The high precedence operations are multiplication and division. For the division operation we have to handle division by zero.</p><pre><code class="ml">let rec factors (opnd1: int): int t =
    (* Parse the factors of a product. *)
    (
        let* op    = mulop in
        let* opnd2 = number
        in
        match op with
        | Times -&gt;
            factors (opnd1 * opnd2)
        | Divide -&gt;
            if opnd2 = 0 then
                fail &quot;division by zero&quot;
            else
                factors (opnd1 / opnd2)
    )
    &lt;/&gt;
    return opnd1

let product: int t =
    (* Parse a product [f1 * f2 / f3 ...]. *)
    let* n = number in
    factors n</code></pre><p>Note that the recursion in <code>factors</code> is guarded. A recursiv call happens only if there is a multiplication operator and an operand.</p><p>In order to parse sums we can directly use the combinator <code>one_or_more_separated</code>.</p><pre><code class="ml">let expr: int t =
    (* Parse a sum [a + b - c ...]. *)
    one_or_more_separated
       (fun x -&gt; x)
       (fun s op x -&gt;
            match op with
            | Plus -&gt;
                s + x
            | Minus -&gt;
                s - x)
       product
       addop</code></pre><p>As a last step we convert the combinator <code>expr</code> to a parser by</p><pre><code class="ml">let calculator: Parser.t =
    make () expr</code></pre><p>and run it on a string</p><pre><code class="ml">let p = Parser.run_on_string &quot;1 + 2 * 6 / 2&quot; calculator

assert (Parser.has_succeeded p);

assert (Parser.final p = 7);


let p = Parser.run_on_string &quot;1 / 0&quot; calculator

assert (Parser.has_failed_semantic p)</code></pre></aside></section><section><header><h2 id="avoid-infinite-recursion"><a href="#avoid-infinite-recursion" class="anchor"></a>Avoid Infinite Recursion</h2></header><aside><p>It is easy to generate a parser which enters an infinite loop. This has to be avoided. <em>General rule:</em> Each recursive call must be protected by some combinator which consume token before the recursive call happens.</p><p>In order to demonstrate valid recursion we use the calculator example of the previous chapter and add parenthesized expressions.</p><pre><code class="ml">let parenthesized (p: unit -&gt; 'a t): 'a t =
    let* _ = char '(' in
    let* _ = whitespace in
    let* x = p () in
    let* _ = char ')' in
    let* _ = whitespace in
    return x</code></pre><p>This combinator parses the combinator <code>p</code> between parentheses. Instead of using an argument of type <code>'a t</code> we use an argument of type <code>unit -&gt; 'a t</code> because the combinator <code>p</code> is usually called recursively.</p><p>The body of <code>parenthesized</code> protects a possible recursive call of <code>p ()</code> by prefixing it by the combinator <code>char '('</code> which certainly consumes a token in case of success.</p><p>As opposed to Haskell, Ocaml is a strict language. In Haskell this particular problem of infinite recursion does not occur, because the Haskell compiler treats internally every expression as a thunk (i.e. of type <code>unit
    -&gt; e</code> instead of <code>e</code>) and evaluates the thunk only if needed.</p><p>Now we can generate a combinator for parenthesized expressions by some mutually recursive functions.</p><pre><code class="ml">let rec expr (): int t =
    ... (* as above using &quot;product ()&quot; instead of &quot;product&quot; *)

and atomic (): int t =
    number &lt;/&gt; parenthesized expr (* recursive call to &quot;expr ()&quot;
                                     not yet done! *)

and product (): int t =
    let* n = atomic () in
    factors n

and factors (opnd1: int): int t =
    let* op    = mulop in
    let* opnd2 = atomic () in
    ... (* same as above *)</code></pre><p>Note that Ocaml does not allow recursive constants. Therefore all elements of a set of mutually recursive functions must be <em>functions</em>. Therefore we added a unit argument to combinators which do not have other arguments.</p></aside></section><section><header><h2 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h2></header><aside><p>Nearly all combinators do not backtrack. I.e. all choices are done by looking only at the first token of a construct. If a construct fails after consuming token, no alternative will be checked.</p><p>This make parsing fast. However sometimes it is necessary to backtrack a failed combinator as if it had not consumed any token. After backtracking, any alternative combinator can be tried. This makes parsing more expensive, because the consumed token have to be pushed back to the lookahead and reparsed by the alternative combinators.</p><p>There are three basic backtracking combinators.</p><ul><li><code>backtrack p expect</code>: Parse <code>p</code>. In case of failure push all consumed token back to the lookahead and continue with possible other choices. Push the expectation <code>expect</code> to the failed expectations.</li></ul><ul><li><code>followed_by p expect</code>: Parse <code>p</code> and push all cosumed token back to the lookahead. Succeed, if <code>p</code> succeeded and fail, if <code>p</code> failed.</li></ul><ul><li><code>not_followed_by p expect</code>: Parse <code>p</code> and push all cosumed token back to the lookahead. Succeed, if <code>p</code> failed and fail, if <code>p</code> succeeded.</li></ul></aside></section><section><header><h2 id="indentation-parsing"><a href="#indentation-parsing" class="anchor"></a>Indentation Parsing</h2></header><aside><p>With the character parser we can parse indented and aligned structures. Each construct gets a set of allowed indentations. The set has a lower indentation bound and an upper indentation bound. The upper indentation bound can be infinite.</p><p>Initially the lower bound of the indentation set is zero and the upper bound is infinite (i.e. the indentation set is <code>{0, 1, ... }</code>)</p><p>No token of a construct is located to the left of the upper indentation bound. If the upper bound is infinite, then token have not yet been encountered. During parsing of a construct token are encountered and its indentation set is finite.</p><p>The default case is that any construct inherits its indentation set from its parent.</p></aside><aside><p>With the combinator</p><pre><code class="ml">indent i p</code></pre><p>we can indent the construct parsed by <code>p</code> by at least <code>i</code> columns relative to its parent.</p></aside><aside><p>To parse aligned constructs we need a parent construct which contains the aligned children. The only purpose of the parent construct is to contain its aligned children. Usually the parent construct is indented (maybe by zero) relative to its parent. E.g. if we want to parse the combinators <code>p</code> and <code>q</code> aligned, we do this by</p><pre><code class="ml">let parent =
    let* a = align p in
    let* b = align q in
    return (a,b)
in
indent 1 (align parent)</code></pre><p>In that case <code>parent</code> is the parent construct which is indented relative to its parent and contains the two aligned children <code>p</code> and <code>q</code>.</p><p>The combinator <code>align</code> aligns within the allowed indentations and the combinator <code>left_align</code> aligns leftmost within the allowed indentations.</p></aside><aside><p>It is <em>important</em> to exclude whitespace from all alignment and indentation requirements. Each line might start with blanks which can violate the requirements. In order to exclude constructs from the alignment and indentation requirements we can use the combinator</p><pre><code class="ml">detach p</code></pre><p>which parses <code>p</code> without any indentation and alignment requirements.</p></aside></section><section><header><h2 id="api"><a href="#api" class="anchor"></a>API</h2></header><dl><dt class="spec module" id="module-Character"><a href="#module-Character" class="anchor"></a><code><span class="keyword">module</span> <a href="Character/index.html">Character</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Character Parser: An indentation sensitive parser which parses streams of characters i.e. the token type is <code>char</code>.</p></dd></dl><dl><dt class="spec module" id="module-Generic"><a href="#module-Generic" class="anchor"></a><code><span class="keyword">module</span> <a href="Generic/index.html">Generic</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A Generic Parser where all parameters are customizable.</p></dd></dl><dl><dt class="spec module" id="module-Position"><a href="#module-Position" class="anchor"></a><code><span class="keyword">module</span> <a href="Position/index.html">Position</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Represent a position in a text file.</p></dd></dl><dl><dt class="spec module" id="module-Located"><a href="#module-Located" class="anchor"></a><code><span class="keyword">module</span> <a href="Located/index.html">Located</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A parsing construct located within a file.</p></dd></dl><dl><dt class="spec module" id="module-Indent"><a href="#module-Indent" class="anchor"></a><code><span class="keyword">module</span> <a href="Indent/index.html">Indent</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The allowed indentations: Helper module for indentation sensitive parsing.</p></dd></dl><div class="spec module" id="module-Interfaces"><a href="#module-Interfaces" class="anchor"></a><code><span class="keyword">module</span> <a href="Interfaces/index.html">Interfaces</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>