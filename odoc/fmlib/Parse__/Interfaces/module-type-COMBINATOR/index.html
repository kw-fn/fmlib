<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>COMBINATOR (fmlib.Parse__.Interfaces.COMBINATOR)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">fmlib</a> &#x00BB; <a href="../../index.html">Parse__</a> &#x00BB; <a href="../index.html">Interfaces</a> &#x00BB; COMBINATOR</nav><h1>Module type <code>Interfaces.COMBINATOR</code></h1><nav class="toc"><ul><li><a href="#basic-combinators">Basic Combinators</a></li><li><a href="#state-combinators">State Combinators</a></li><li><a href="#convenience-combinators">Convenience Combinators</a></li><li><a href="#backtracking">Backtracking</a></li></ul></nav></header><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code></dt><dt class="spec type" id="type-expect"><a href="#type-expect" class="anchor"></a><code><span class="keyword">type</span> expect</code></dt><dt class="spec type" id="type-semantic"><a href="#type-semantic" class="anchor"></a><code><span class="keyword">type</span> semantic</code></dt></dl><section><header><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic Combinators</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>_ t</span></code></dt><dd><p><code>'a t</code> Type of a parse combinator returning an <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &gt;&gt;= f</code></p><p>Parse first the input according to the combinator <code>p</code>. In case of success, feed the returned value of <code>p</code> into the function <code>f</code> to get the combinator to parse next.</p></dd></dl><dl><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>let* x = p in f x</code> is equivalent to <code>p &gt;&gt;= f</code></p><p>The <code>let*</code> combinator let us express parsing sequences conveniently. Example:</p><pre><code class="ml">let* x = p in       (* parse [p], result [x] in case of success. *)
let* y = q x in     (* parse [q x], result [y] ... *)
let* z = r x y in   (* ... *)
...
return f x y z ...</code></pre><p>The wildcard <code>let* _ = ...</code> can be used to ignore results of intermediate parsing steps.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map f p</code></p><p>Try combinator <code>p</code>. In case of success, map the returned value <code>x</code> to <code>f
        x</code>. In case of failure, do nothing.</p><p><code>map f p</code> is equivalent to <code>let* x = p in return (f x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-succeed"><a href="#val-succeed" class="anchor"></a><code><span class="keyword">val</span> succeed : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>succeed a</code></p><p>Succeed immediately without consuming token. Return object <code>a</code> as result.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return a</code> is equivalent to <code>succeed a</code>.</p></dd></dl><dl><dt class="spec value" id="val-unexpected"><a href="#val-unexpected" class="anchor"></a><code><span class="keyword">val</span> unexpected : <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unexpected expect</code> triggers a syntax error signalling the expectation <code>expect</code>.</p></dd></dl><dl><dt class="spec value" id="val-clear_last_expectation"><a href="#val-clear_last_expectation" class="anchor"></a><code><span class="keyword">val</span> clear_last_expectation : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>clear_last_expectation p</code> Clear last failed expectation.</p><p>This is useful e.g. after stripping whitespace. Since stripping whitespace means <code>skip_one_or_more ws</code> or <code>skip_zero_or_more ws</code>, after skipping whitespace the parser can still expect more whitespace. Therefore there is a failed expectation *whitespace* on the stack. However you rarely want this expectation to be reported.</p></dd></dl><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : <a href="index.html#type-semantic">semantic</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fail error</code> triggers a semantic error.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;/&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;/&gt; q</code></p><p>Try first combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;/&gt; q</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then <code>p &lt;/&gt; q</code> is equivalent to <code>q</code>.</p></dd></dl><dl><dt class="spec value" id="val-choices"><a href="#val-choices" class="anchor"></a><code><span class="keyword">val</span> choices : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>choices p [q r t ...]</code> is equivalent to <code>p &lt;/&gt; q &lt;/&gt; r &lt;/&gt; t &lt;/&gt; ...</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;?&gt;)"><a href="#val-(&lt;?&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;?&gt;) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>p &lt;?&gt; expect</code></p><p>Try combinator <code>p</code>. In case of success or failure with consumed token, <code>p &lt;?&gt; expect</code> is equivalent to <code>p</code>.</p><p>If <code>p</code> fails without consuming token, then the failed expectations are replaced with the failed expectation <code>expect</code>.</p><p>Usually <code>p</code> is a combinator implementing a choice between various alternatives of a grammar construct. The <code>&lt;?&gt;</code> combinator allows to replace the set of failed grammar alternatives with a higher abstraction of the failed expectation. E.g. instead of getting the failed expectations <code>identifier</code>, <code>'('</code>, <code>-</code>, ... we can get the failed expectation <code>expression</code>.</p></dd></dl></section><section><header><h3 id="state-combinators"><a href="#state-combinators" class="anchor"></a>State Combinators</h3></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><a href="index.html#type-state">state</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Get the current user state.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <span>(<a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update f</code> Update the user state using <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_and_update"><a href="#val-get_and_update" class="anchor"></a><code><span class="keyword">val</span> get_and_update : <span>(<a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-state">state</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>get_and_update f</code> Get the current user state and then update the user state. The returned value is the old state.</p></dd></dl></section><section><header><h3 id="convenience-combinators"><a href="#convenience-combinators" class="anchor"></a>Convenience Combinators</h3></header><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>optional p</code></p><p>Try combinator <code>p</code>.</p><ul><li>Success: Return <code>Some a</code> where <code>a</code> is the returned value.</li><li>Failure without consuming token: Return <code>None</code></li><li>Failure with consuming token: Remain in the error state.</li></ul></dd></dl><dl><dt class="spec value" id="val-zero_or_more"><a href="#val-zero_or_more" class="anchor"></a><code><span class="keyword">val</span> zero_or_more : <span class="type-var">'r</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zero_or_more start f p</code></p><p>Try the combinator <code>p</code> as often as possible. Return <code>start</code> if <code>p</code> fails without consuming token. As long as <code>p</code> succeeds use <code>f</code> to accumulate the results.</p><p>The first time <code>p</code> fails without consuming token, return the accumulated result.</p><p>If <code>p</code> fails by consuming token, then <code>zero_or_more f p</code> fails with the same error.</p></dd></dl><dl><dt class="spec value" id="val-one_or_more"><a href="#val-one_or_more" class="anchor"></a><code><span class="keyword">val</span> one_or_more : <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>one_or_more first next p</code></p><p><code>one_or_more first next p</code> is equivalent to</p><pre><code class="ml">let* x = p in
zero_or_more (first x) next p</code></pre></dd></dl><dl><dt class="spec value" id="val-list_zero_or_more"><a href="#val-list_zero_or_more" class="anchor"></a><code><span class="keyword">val</span> list_zero_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list_zero_or_more p</code> Parse zero or more occurrences of <code>p</code> and returned the collected result in a list.</p></dd></dl><dl><dt class="spec value" id="val-list_one_or_more"><a href="#val-list_one_or_more" class="anchor"></a><code><span class="keyword">val</span> list_one_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list_zero_or_more p</code> Parse one or more occurrences of <code>p</code> and returned the collected results as a pair of the first value and a list of the remaining values.</p></dd></dl><dl><dt class="spec value" id="val-skip_zero_or_more"><a href="#val-skip_zero_or_more" class="anchor"></a><code><span class="keyword">val</span> skip_zero_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_zero_or_more p</code> Parse zero or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></dd></dl><dl><dt class="spec value" id="val-skip_one_or_more"><a href="#val-skip_one_or_more" class="anchor"></a><code><span class="keyword">val</span> skip_one_or_more : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>skip_one_or_more p</code> Parse one or more occurrences of <code>p</code>, ignore the result and return the number of occurrences.</p></dd></dl><dl><dt class="spec value" id="val-one_or_more_separated"><a href="#val-one_or_more_separated" class="anchor"></a><code><span class="keyword">val</span> one_or_more_separated : <span>(<span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'sep</span> <span>&#45;&gt;</span> <span class="type-var">'item</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'item</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'sep</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>one_or_more_separated first next p sep</code></p><p>Parse one or more occurrences of <code>p</code> separated by <code>sep</code>. Use <code>first</code> to convert the first occurrence of <code>p</code> into the result and use <code>next</code> to accumulate the results.</p></dd></dl></section><section><header><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3></header><dl><dt class="spec value" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span class="keyword">val</span> backtrack : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>backtrack p expect</code></p><p>Try the combinator <code>p</code>. In case of failure with consuming token, push the consumed token back to the lookahead and let it fail without consuming token. Use <code>expect</code> to record the failed expectation.</p><p>Backtracking reduces the performance, because the token pushed back to the lookahead have to be parsed again. Try to avoid backtracking whenever possible.</p></dd></dl><dl><dt class="spec value" id="val-followed_by"><a href="#val-followed_by" class="anchor"></a><code><span class="keyword">val</span> followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>followed_by</code> parser succeeds without consuming token. Otherwise it fails without consuming tokens.</p></dd></dl><dl><dt class="spec value" id="val-not_followed_by"><a href="#val-not_followed_by" class="anchor"></a><code><span class="keyword">val</span> not_followed_by : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-expect">expect</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>not_followed_by p expect</code></p><p>Parses <code>p</code> and backtracks (i.e. all tokens of <code>p</code> will be pushed back to the lookahead). In case <code>p</code> succeeds, the <code>not_followed_by</code> parser fails without consuming token. Otherwise it succeeds without consuming tokens.</p></dd></dl><aside><p><code>followed_by</code> and <code>not_followed_by</code> can be used to peek into the token stream without consuming token.</p></aside></section></div></body></html>